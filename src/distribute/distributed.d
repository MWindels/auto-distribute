/**
 * Wraps a data structure with some distributed consensus logic.
 *
 * Author: Michael Windels.
 */
module distribute.distributed;

import std.traits;
import std.string;

public:

/**
 * Provides consensus logic for an instance of its template parameter.
 * Mimics the member functions and member variables of its template parameter.
 */
class Distributed(T)
{
	/**
	 * Returns a mimicry of some function's declaration as a string.
	 * External linkages are omitted, as are the pure, nothrow, trusted, safe, and nogc function attributes. 
	 * Intended to be called at compile time.
	 *
	 * Params:
	 * 	name = The name of the function represented by symbol.
	 *
	 * Returns: A string representing a function declaration (without a final semicolon).
	 */
	private static string _mimicFuncDecl(alias symbol)(immutable string name) pure @safe
	if(isFunction!symbol /*|| isDelegate!symbol*/)
	{
		//Begin the declaration with the access modifier.
		string decl = __traits(getProtection, symbol) ~ " ";	//Note: This does not capture the parameterization of the package specifier.
		
		//Add abstract if symbol is abstract.
		static if(__traits(isAbstractFunction, symbol))
		{
			decl ~= "abstract ";
		}
		
		//Add final if symbol is final.
		static if(__traits(isFinalFunction, symbol))
		{
			decl ~= "final ";
		}
		
		//Add static if symbol is static.
		static if(__traits(isStaticFunction, symbol))
		{
			decl ~= "static ";
		}
		
		//Add user-defined attributes (if any).
		alias uAttributes = __traits(getAttributes, symbol);
		static if(uAttributes.length > 0)
		{
			decl ~= "@(";
			static foreach(immutable idx; 0 .. uAttributes.length)
			{
				decl ~= uAttributes[idx].stringof;
				static if(idx + 1 < uAttributes.length)
				{
					decl ~= ", ";
				}
			}
			decl ~= ") ";
		}
		
		//Add acceptable function attributes (if any).
		alias fAttributes = functionAttributes!symbol;
		static if(fAttributes & FunctionAttribute.ref_)
		{
			decl ~= "ref ";
		}
		static if(fAttributes & FunctionAttribute.property)
		{
			decl ~= "@property ";
		}
		static if(fAttributes & FunctionAttribute.system)
		{
			decl ~= "@system ";
		}
		static if(fAttributes & FunctionAttribute.const_)
		{
			decl ~= "const ";
		}
		static if(fAttributes & FunctionAttribute.immutable_)
		{
			decl ~= "immutable ";
		}
		static if(fAttributes & FunctionAttribute.inout_)
		{
			decl ~= "inout ";
		}
		static if(fAttributes & FunctionAttribute.shared_)
		{
			decl ~= "shared ";
		}
		static if(fAttributes & FunctionAttribute.return_)
		{
			decl ~= "return ";
		}
		static if(fAttributes & FunctionAttribute.scope_)
		{
			decl ~= "scope ";
		}
		
		//Add return type and name.
		decl ~= (ReturnType!symbol).stringof ~ " " ~ name ~ "(";
		
		//Add parameters (if any).
		alias pType = Parameters!symbol;
		alias pName = ParameterIdentifierTuple!symbol;
		alias pStorage = ParameterStorageClassTuple!symbol;
		alias pDefault = ParameterDefaults!symbol;
		static assert(pType.length == pName.length && pType.length == pStorage.length && pType.length == pDefault.length);
		static foreach(immutable idx; 0 .. pType.length)
		{
			//Add parameter storage classes (if any).
			static if(pStorage[idx] & ParameterStorageClass.scope_)
			{
				decl ~= "scope ";
			}
			static if(pStorage[idx] & ParameterStorageClass.out_)
			{
				decl ~= "out ";
			}
			static if(pStorage[idx] & ParameterStorageClass.ref_)
			{
				decl ~= "ref ";
			}
			static if(pStorage[idx] & ParameterStorageClass.lazy_)
			{
				decl ~= "lazy ";
			}
			static if(pStorage[idx] & ParameterStorageClass.return_)
			{
				decl ~= "return ";
			}
			
			//Add parameter type and name.
			decl ~= pType[idx].stringof ~ " " ~ pName[idx];
			
			//Add parameter default value (if any).
			static if(!is(pDefault[idx] == void))
			{
				decl ~= " = " ~ pDefault[idx].stringof;
			}
			
			//Prepare for the next parameter (if any).
			static if(idx + 1 < pType.length)
			{
				decl ~= ", ";
			}
		}
		
		decl ~= ")";
		return decl;
	}
	
	/**
	 * Returns a function definition for some function symbol.
	 * Used in conjunction with the declaration generated by _mimicFuncDecl.
	 * Intended to be called at compile time.
	 *
	 * Params:
	 * 	name = The name of the function represented by symbol.
	 *
	 * Returns: A string representing a function definition.
	 */
	private static string _mimicFuncDef(alias symbol)(string name) pure @safe
	if(isFunction!symbol /*|| isDelegate!symbol*/)
	{
		static if(!is(ReturnType!symbol == void))
		{
			return "{return " ~ (ReturnType!symbol).stringof ~ ".init;}";
		}
		else
		{
			return "{}";
		}
	}
	
	static if(__traits(compiles, __traits(allMembers, T)))	//This is a roundabout way of ensuring that T actually has members.
	{
		static foreach(immutable member; __traits(allMembers, T))
		{
			static if(isFunction!(__traits(getMember, T, member)))
			{
				static if(!__traits(hasMember, Distributed!T, member))
				{
					static foreach(immutable overload; __traits(getOverloads, T, member))
					{
						mixin(_mimicFuncDecl!overload(member) ~ " " ~ _mimicFuncDef!overload(member));
					}
				}
			}
		}
	}
}



struct Test
{
	float x = 10;
	
	final void foo(int a) {}
	@(1) int bar(ref double d, double e) {return cast(int)(d + e);}
	package inout(float) baz() inout {return x;}
	
	static long hey() {return 1;}
}

void printMembers(T)()
{
	import std.stdio : writeln;
	
	writeln("---", T.stringof, "---");
	
	static foreach(immutable member; __traits(allMembers, Distributed!T))
	{
		writeln(member);
		writeln("\t", __traits(getProtection, __traits(getMember, Distributed!T, member)));
		writeln("\tAbstract: ", __traits(isAbstractFunction, __traits(getMember, Distributed!T, member)));
		writeln("\tFinal: ", __traits(isFinalFunction, __traits(getMember, Distributed!T, member)));
		writeln("\tStatic: ", __traits(isStaticFunction, __traits(getMember, Distributed!T, member)));
		static if(__traits(compiles, typeof(__traits(getMember, Distributed!T, member))))
		{
			writeln("\t", typeof(__traits(getMember, Distributed!T, member)).stringof);
		}
		else
		{
			writeln("\t", __traits(getMember, Distributed!T, member).stringof);
		}
		writeln("\t", __traits(getMember, Distributed!T, member).mangleof);
	}
	
	writeln();
}

void main()
{
	printMembers!int();
	printMembers!Test();
}