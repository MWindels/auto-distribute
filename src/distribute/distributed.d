/**
 * Wraps a data structure with some distributed consensus logic.
 *
 * Author: Michael Windels.
 */
module distribute.distributed;

import std.traits;
import std.string;
import distribute.distributed_base;
import distribute.utils;

private:

/**
 * Returns a tuple of symbol's User-Defined Attributes (UDAs) as a string prefixed with an @.
 * If symbol has UDAs, the result is also suffixed with a space.
 * Intended to be called at compile time.
 *
 * Returns: A string tuple of symbol's UDAs.
 */
static string _mimicUDAs(alias symbol)() pure @safe
{
	string udas = "";
	
	//If symbol has UDAs, create a tuple of them.
	alias uAttributes = __traits(getAttributes, symbol);
	static if(uAttributes.length > 0)
	{
		udas ~= "@(";
		static foreach(immutable idx; 0 .. uAttributes.length)
		{
			udas ~= uAttributes[idx].stringof;
			static if(idx + 1 < uAttributes.length)
			{
				udas ~= ", ";
			}
		}
		udas ~= ") ";
	}
	
	return udas;
}

/**
 * Returns a mimicry of some function's declaration as a string.
 * External linkages are omitted, as are the pure, nothrow, trusted, safe, and nogc function attributes.
 * Parameterizations of the package access specifier are also omitted.
 * Intended to be called at compile time.
 *
 * Params:
 * 	name = The name of the function represented by symbol.
 *
 * Returns: A string representing a function declaration (without a final semicolon).
 */
static string _mimicFuncDecl(alias symbol)(immutable string name) pure @safe
if(isFunction!symbol || isDelegate!symbol)
{
	//Begin the declaration with the access modifier.
	string decl = __traits(getProtection, symbol) ~ " ";	//Note: This does not capture the parameterization of the package specifier.
	
	//Add abstract if symbol is abstract.
	static if(__traits(isAbstractFunction, symbol))
	{
		decl ~= "abstract ";
	}
	
	//Add final if symbol is final.
	static if(__traits(isFinalFunction, symbol))
	{
		decl ~= "final ";
	}
	
	//Add static if symbol is static.
	static if(__traits(isStaticFunction, symbol))
	{
		decl ~= "static ";
	}
	
	//Add user-defined attributes (if any).
	decl ~= _mimicUDAs!symbol();
	
	//Add acceptable function attributes (if any).
	alias fAttributes = functionAttributes!symbol;
	static if(fAttributes & FunctionAttribute.ref_)
	{
		decl ~= "ref ";
	}
	static if(fAttributes & FunctionAttribute.property)
	{
		decl ~= "@property ";
	}
	static if(fAttributes & FunctionAttribute.system)
	{
		decl ~= "@system ";
	}
	static if(fAttributes & FunctionAttribute.const_)
	{
		decl ~= "const ";
	}
	static if(fAttributes & FunctionAttribute.immutable_)
	{
		decl ~= "immutable ";
	}
	static if(fAttributes & FunctionAttribute.inout_)
	{
		decl ~= "inout ";
	}
	static if(fAttributes & FunctionAttribute.shared_)
	{
		decl ~= "shared ";
	}
	static if(fAttributes & FunctionAttribute.return_)
	{
		decl ~= "return ";
	}
	static if(fAttributes & FunctionAttribute.scope_)
	{
		decl ~= "scope ";
	}
	
	//Add return type and name.
	decl ~= (ReturnType!symbol).stringof ~ " " ~ name ~ "(";
	
	//Add parameters (if any).
	alias pType = Parameters!symbol;
	alias pName = ParameterIdentifierTuple!symbol;
	alias pStorage = ParameterStorageClassTuple!symbol;
	alias pDefault = ParameterDefaults!symbol;
	static assert(pType.length == pName.length && pType.length == pStorage.length && pType.length == pDefault.length);
	static foreach(immutable idx; 0 .. pType.length)
	{
		//Add parameter storage classes (if any).
		static if(pStorage[idx] & ParameterStorageClass.scope_)
		{
			decl ~= "scope ";
		}
		static if(pStorage[idx] & ParameterStorageClass.out_)
		{
			decl ~= "out ";
		}
		static if(pStorage[idx] & ParameterStorageClass.ref_)
		{
			decl ~= "ref ";
		}
		static if(pStorage[idx] & ParameterStorageClass.lazy_)
		{
			decl ~= "lazy ";
		}
		static if(pStorage[idx] & ParameterStorageClass.return_)
		{
			decl ~= "return ";
		}
		
		//Add parameter type and name.
		decl ~= pType[idx].stringof ~ " " ~ pName[idx];
		
		//Add parameter default value (if any).
		static if(!is(pDefault[idx] == void))
		{
			decl ~= " = " ~ pDefault[idx].stringof;
		}
		
		//Prepare for the next parameter (if any).
		static if(idx + 1 < pType.length)
		{
			decl ~= ", ";
		}
	}
	
	decl ~= ")";
	return decl;
}

/**
 * Returns a function definition for some function symbol.
 * Used in conjunction with the declaration generated by _mimicFuncDecl.
 * Intended to be called at compile time.
 *
 * Params:
 * 	name = The name of the function represented by symbol.
 *
 * Returns: A string representing a function definition.
 */
static string _mimicFuncDef(alias symbol)(immutable string name) pure @safe
if(isFunction!symbol || isDelegate!symbol)
{
	static if(!is(ReturnType!symbol == void))
	{
		return "{static " ~ (ReturnType!symbol).stringof ~ " ret = " ~ (ReturnType!symbol).stringof ~ ".init; return ret;}";
	}
	else
	{
		return "{}";
	}
}

/**
 * Returns a function declaration and definition for some function symbol.
 * Intended to be called at compile time.
 *
 * Params:
 * 	name = The name of the function represented by symbol.
 *
 * Returns: A string representing a function declaration and definition.
 */
static string _mimicFunction(alias symbol)(immutable string name) pure @safe
if(isFunction!symbol || isDelegate!symbol)
{
	return _mimicFuncDecl!symbol(name) ~ " " ~ _mimicFuncDef!symbol(name);
}

/**
 * Returns a field declaration for some field symbol.
 * External linkages are omitted, as are any parameterizations for the package access modifier.
 * Intended to be called at compile time.
 *
 * Params:
 * 	name = The name of the field represented by symbol.
 *
 * Returns: A string representing a field declaration.
 */
static string _mimicField(alias symbol)(immutable string name) pure @safe
if(!isFunction!symbol && !isDelegate!symbol && !is(symbol))
{
	//Start with the field's access modifier.
	string field = __traits(getProtection, symbol) ~ " ";
	
	//Add static if we can take the symbol's address.
	//See std.traits.hasStaticMember for something similar.
	static if(__traits(compiles, &symbol))
	{
		field ~= "static ";
	}
	
	//Add user-defined attributes (if any).
	field ~= _mimicUDAs!symbol();
	
	//Add the new Distributed type, move the original type qualifiers out, and name of the new field.
	field ~= CopyTypeQualifiers!(typeof(symbol), Distributed!(Unqual!(typeof(symbol)))).stringof ~ " " ~ name;
	
	return field ~ ";";
}

/**
 * Returns a type alias for some type name belonging to type T.
 * Intended to be called at compile time.
 *
 * Params:
 * 	name = The name of some type which is a member of type T.
 *
 * Returns: A string representing a type alias.
 */
static string _mimicType(alias symbol)(immutable string name) pure @safe
if(is(symbol))
{
	return "alias " ~ name ~ " = T." ~ name ~ ";";
}


public:

/**
 * Provides consensus logic for an instance of its template parameter.
 * Mimics the member functions and member variables of its template parameter.
 */
class Distributed(T) : Distributed_Base!T
{
	mixin(forAllMembers!(T, _mimicFunction, _mimicField, _mimicType)());
}
unittest
{
	class Example
	{
		this();
		~this();
		
		class T1
		{
			int a;
			float b;
			double c;
		}
		struct T2
		{
			bool a;
			string b;
		}
		union T3
		{
			int a;
			float b;
			long c;
		}
		enum T4 {A, B, C}
		export interface T5
		{
			void foo();
		}
		private enum T6 {X, Y, Z}
		protected struct T7
		{
			char a;
			long b;
		}
		package class T8
		{
			int foo();
		}
		
		int a;
		const float b;
		shared double c;
		static immutable bool d;
		export long function() e;
		private int f;
		protected immutable float g;
		package shared double h;
		
		void f1() {}
		void f1(char x) {}
		void f1(bool x, string y) {}
		static int f2(int x) {return x;}
		static int f2(int x, long y) {return x;}
		abstract ref const(float) f3(return ref const float x) {return x;}
		//@T1 @T3 final string f4(int x, ref inout long y) inout {return "";}	//Two issues: (1) UDAs are not recognized as the same type, (2) ref attribute of y is optimized to return in the original and removed in the distributed version (likely because of the function bodies).
		//@T2 void f5(ref T1, ref immutable T2, out T3) const nothrow {}	//Has issue (1).
	}
	
	/**
	 * Tests whether two compile-time sequences are equal (hence seq-equal, or sequal).
	 * Would have been defined as a template mixin, but they can only contain definitions.
	 * This is meant to be mixed-in rather than called.
	 */
	immutable string sequal(string a, string b) = "
		static if(" ~ a ~ ".length == " ~ b ~ ".length)
		{
			static foreach(immutable idx; 0 .. " ~ a ~ ".length)
			{
				static if(is(" ~ a ~ "[idx]) && is(" ~ b ~ "[idx]))
				{
					valid &= is(" ~ a ~ "[idx] == " ~ b ~ "[idx]);
				}
				else static if(!is(" ~ a ~ "[idx]) && !is(" ~ b ~ "[idx]))
				{
					valid &= " ~ a ~ "[idx] == " ~ b ~ "[idx];
				}
				else
				{
					valid &= false;
				}
			}
		}
		else
		{
			valid &= false;
		}
	";
	
	/**
	 * Tests whether the interfaces of T and Distributed!T are sufficiently similar.
	 */
	void test(T)()
	{
		foreach(immutable member; __traits(allMembers, T))
		{
			static if(member != "this")
			{
				static if(member.length < 2 || !(member[0] == '_' && member[1] == '_'))
				{
					alias tSymbol = __traits(getMember, T, member);
					static if(!__traits(isTemplate, tSymbol))
					{
						static if(isFunction!tSymbol || isDelegate!tSymbol)
						{
							static foreach(immutable tOverload; __traits(getOverloads, T, member))
							{
								static if(IsAccessible!tOverload)
								{
									assert(
										function bool()
										{
											foreach(immutable dOverload; __traits(getOverloads, Distributed!T, member))
											{
												bool valid = true;
												valid &= __traits(getProtection, tOverload) == __traits(getProtection, dOverload);
												valid &= __traits(isAbstractFunction, tOverload) == __traits(isAbstractFunction, dOverload);
												valid &= __traits(isFinalFunction, tOverload) == __traits(isFinalFunction, dOverload);
												valid &= __traits(isStaticFunction, tOverload) == __traits(isStaticFunction, dOverload);
												mixin(sequal!("__traits(getAttributes, tOverload)", "__traits(getAttributes, dOverload)"));
												valid &= (functionAttributes!tOverload & ~(FunctionAttribute.pure_ | FunctionAttribute.nothrow_ | FunctionAttribute.trusted | FunctionAttribute.safe | FunctionAttribute.nogc)) == (functionAttributes!dOverload & ~(FunctionAttribute.pure_ | FunctionAttribute.nothrow_ | FunctionAttribute.trusted | FunctionAttribute.safe | FunctionAttribute.nogc));
												valid &= is(ReturnType!tOverload == ReturnType!dOverload);
												valid &= is(Parameters!tOverload == Parameters!dOverload);
												mixin(sequal!("ParameterIdentifierTuple!tOverload", "ParameterIdentifierTuple!dOverload"));
												mixin(sequal!("ParameterStorageClassTuple!tOverload", "ParameterStorageClassTuple!dOverload"));
												mixin(sequal!("ParameterDefaults!tOverload", "ParameterDefaults!dOverload"));
												if(valid)
												{
													return true;
												}
											}
											return false;
										}(),
										"Function " ~ member ~ " has no matching overload.\n\tWas: " ~ _mimicFuncDecl!tSymbol(member) ~ "\n\tIs: " ~ _mimicFuncDecl!(__traits(getMember, Distributed!T, member))(member)
									);
								}
							}
						}
						else
						{
							static if(IsAccessible!tSymbol)
							{
								alias dSymbol = __traits(getMember, Distributed!T, member);
								static if(is(tSymbol))
								{
									//How should we check aliased types?
								}
								else
								{
									assert(
										__traits(getProtection, tSymbol) == __traits(getProtection, dSymbol),
										"Field " ~ member ~ " was " ~ __traits(getProtection, tSymbol) ~ ", but it is now " ~ __traits(getProtection, dSymbol) ~ "."
									);
									assert(
										__traits(compiles, &tSymbol) == __traits(compiles, &dSymbol),
										"Field " ~ member ~ " was" ~ (__traits(compiles, &tSymbol) ? " " : " not ") ~ "static, but now it is" ~ (__traits(compiles, &dSymbol) ? " " : " not ") ~ "static."
									);
									assert(
										__traits(getAttributes, tSymbol) == __traits(getAttributes, dSymbol),
										"Field " ~ member ~ " had UDAs [" ~ __traits(getAttributes, tSymbol).stringof ~ "], but now it has UDAs [" ~ __traits(getAttributes, dSymbol).stringof ~ "]."
									);
									assert(
										is(CopyTypeQualifiers!(typeof(tSymbol), T) == CopyTypeQualifiers!(typeof(dSymbol), T)),
										"Field " ~ member ~ " had qualifiers of " ~ (CopyTypeQualifiers!(typeof(tSymbol), T)).stringof ~ ", but now it has the qualifiers of " ~ (CopyTypeQualifiers!(typeof(dSymbol), T)).stringof ~ "."
									);
									assert(
										is(Distributed!(Unqual!(typeof(tSymbol))) == Unqual!(typeof(dSymbol))),
										"Field " ~ member ~ " had type " ~ (Distributed!(Unqual!(typeof(tSymbol)))).stringof ~ ", but now it has type " ~ (Unqual!(typeof(dSymbol))).stringof ~ "."
									);
								}
							}
						}
					}
				}
			}
		}
	}
	
	test!Example();
}