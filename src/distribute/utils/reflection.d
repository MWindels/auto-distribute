/**
 * Provides some frequently needed reflection capabilities and mixin utilities.
 *
 * Author: Michael Windels.
 */
module distribute.utils.reflection;

import std.traits;
import std.meta : AliasSeq;
import distribute.distributed_base;
import distribute.utils.tmp;

private:

/**
 * Function which returns an empty string.
 * Used only as a default value for forAlias in forAllMembers.
 *
 * Returns: An empty string.
 */
static string _noAlias(alias _)(immutable string, immutable string) pure @safe nothrow @nogc
{
	return "";
}


package(distribute):

/**
 * Function which returns an empty string.
 * Meant to be used in conjunction with forAllMembers if no code is desired for function, field, or type members.
 *
 * Returns: An empty string.
 */
static string nop(alias _)(immutable string) pure @safe nothrow @nogc
{
	return "";
}

/**
 * Generates code (as a string) by iterating over all the members of some type T.
 * The forFunction, forField, forType, and forAlias template parameters are assumed to be symbols representing functions which:
 * 	- Return a string.
 * 	- Take one alias template parameter (a member symbol).
 * 	- Take one immutable string parameter (a member name).
 * Additionally, forAlias is supplied one more string parameter (the name of the symbol to which the template parameter symbol is aliased).
 * Unlike the other template parameters, forAlias defaults to a no-op (as the nop function used for the other three cannot be supplied to it).
 * All four functions must be callable at compile time, as this function is intended to be called at compile time.
 *
 * Returns: A string of code generated by applying the forFunction, forField, forType, and forAlias functions over the members of type T.
 */
static string forAllMembers(T, alias forFunction, alias forField, alias forType, alias forAlias = _noAlias)() pure @safe
if(__traits(isTemplate, forFunction) && __traits(isTemplate, forField) && __traits(isTemplate, forType) && __traits(isTemplate, forAlias))
{
	string code = "";
	string[string] aliases;
	
	static if(is(T == class) || is(T == struct) || is(T == union))
	{
		static foreach(immutable member; __traits(allMembers, T))
		{
			static if(member != "this")	//Ignore the context pointer (if it exists).
			{
				static if(member.length < 2 || !(member[0] == '_' && member[1] == '_'))	//Ignore double-underscore members, they're reserved.
				{
					static if(AliasSeq!(__traits(getMember, T, member)).length == 1)	//Because compile-time sequences auto-expand, we can't supply them to any of the templates used below.
					{
						static if(!__traits(isTemplate, __traits(getMember, T, member)))	//Ignore templates, they return no type (void).
						{
							static if(!__traits(hasMember, Distributed_Base!T, member))
							{
								static if(isFunction!(__traits(getMember, T, member)) || isDelegate!(__traits(getMember, T, member)))
								{
									static foreach(immutable overload; __traits(getOverloads, T, member))
									{
										static if(IsAccessible!overload)
										{
											if((overload.mangleof in aliases) == null)
											{
												code ~= forFunction!overload(member);
												aliases[overload.mangleof] = member;
											}
											else
											{
												code ~= forAlias!overload(member, aliases[overload.mangleof]);
											}
										}
									}
								}
								else
								{
									static if(IsAccessible!(__traits(getMember, T, member)))
									{
										static if(is(__traits(getMember, T, member)))
										{
											if((__traits(getMember, T, member).mangleof in aliases) == null)
											{
												code ~= forType!(__traits(getMember, T, member))(member);
												aliases[__traits(getMember, T, member).mangleof] = member;
											}
											else
											{
												code ~= forAlias!(__traits(getMember, T, member))(member, aliases[__traits(getMember, T, member).mangleof]);
											}
										}
										else
										{
											if((__traits(getMember, T, member).mangleof in aliases) == null)
											{
												code ~= forField!(__traits(getMember, T, member))(member);
												aliases[__traits(getMember, T, member).mangleof] = member;
											}
											else
											{
												code ~= forAlias!(__traits(getMember, T, member))(member, aliases[__traits(getMember, T, member).mangleof]);
											}
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
	
	return code;
}